local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Camera = workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

local function printAction(message)
    if Faith.Misc.PrintMode then
        print("[Faith] " .. message)
    end
end

do
    local success, err = pcall(function()
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "FaithIntroGui"
        screenGui.IgnoreGuiInset = true
        screenGui.ResetOnSpawn = false
        screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui", 5)

        local textLabel = Instance.new("TextLabel")
        textLabel.Name = "FaithText"
        textLabel.Size = UDim2.new(0.5, 0, 0.2, 0)
        textLabel.Position = UDim2.new(0.25, 0, 0.4, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.Text = "faith.dev"
        textLabel.TextColor3 = Color3.fromRGB(175, 134, 144)
        textLabel.TextScaled = true
        textLabel.Font = Enum.Font.Nunito
        textLabel.TextTransparency = 0
        textLabel.Parent = screenGui

        task.wait(3)
        screenGui:Destroy()
    end)
    if not success then
        printAction("Failed to display intro: " .. tostring(err))
    end
end

local FOVCircle = Drawing.new("Circle")
FOVCircle.Color = Faith.SilentAim.FOV.OutlineColor
FOVCircle.Thickness = Faith.SilentAim.FOV.Thickness
FOVCircle.Transparency = Faith.SilentAim.FOV.Transparency
FOVCircle.Radius = Faith.SilentAim.FOV.Radius

local IsToggled = false
local Target = { Player = nil, TargetPart = nil }
local Tween
local Info
local Cycle

getgenv().is_firing = false

local SilentAimModule = {}

function SilentAimModule:IsHoldingKnife()
    if not (Faith.SilentAim.KnifeCheck or Faith.Camlock.KnifeCheck) then
        return false
    end
    local Character = LocalPlayer.Character
    if Character then
        local Tool = Character:FindFirstChildOfClass("Tool")
        return Tool and Tool.Name == "Knife"
    end
    return false
end

function SilentAimModule:GetClosestPart(Character, MousePosition)
    local ClosestDistance, ClosestPart = math.huge, nil
    local Parts = {"Head", "HumanoidRootPart", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", "UpperTorso"}
    for _, PartName in ipairs(Parts) do
        local Part = Character:FindFirstChild(PartName)
        if Part then
            local ScreenPosition, Visible = Camera:WorldToViewportPoint(Part.Position)
            if Visible then
                local Distance = (MousePosition - Vector2.new(ScreenPosition.X, ScreenPosition.Y)).Magnitude
                if Distance < ClosestDistance then
                    ClosestDistance, ClosestPart = Distance, Part
                end
            end
        end
    end
    return ClosestPart
end

function SilentAimModule:GetRandomPart(Character)
    local Parts = {"Head", "HumanoidRootPart", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", "UpperTorso"}
    local ValidParts = {}
    for _, PartName in ipairs(Parts) do
        local Part = Character:FindFirstChild(PartName)
        if Part then
            table.insert(ValidParts, Part)
        end
    end
    if #ValidParts > 0 then
        return ValidParts[math.random(1, #ValidParts)]
    end
    return nil
end

function SilentAimModule:GetClosestPlayer()
    local ClosestDistance, ClosestPart = math.huge, nil
    local MousePosition = UserInputService:GetMouseLocation()
    for _, Player in next, Players:GetPlayers() do
        if Player ~= LocalPlayer and Player.Character then
            local Character = Player.Character
            local Humanoid = Character:FindFirstChild("Humanoid")
            if Humanoid and (not Faith.SilentAim.KnockCheck or Humanoid.Health > 0) then
                local TargetPart
                if Faith.SilentAim.HitPartMode == "Closest" then
                    TargetPart = self:GetClosestPart(Character, MousePosition)
                elseif Faith.SilentAim.HitPartMode == "Random" then
                    TargetPart = self:GetRandomPart(Character)
                else
                    TargetPart = Character:FindFirstChild(Faith.SilentAim.HitPart) or Character:FindFirstChild("Torso") or Character:FindFirstChild("UpperTorso")
                end
                if TargetPart then
                    local ScreenPosition, Visible = Camera:WorldToViewportPoint(TargetPart.Position)
                    if Visible then
                        local Distance = (MousePosition - Vector2.new(ScreenPosition.X, ScreenPosition.Y)).Magnitude
                        if Distance <= Faith.SilentAim.FOV.Radius and Distance < ClosestDistance then
                            ClosestDistance, ClosestPart = Distance, TargetPart
                        end
                    end
                end
            end
        end
    end
    return ClosestPart
end

function SilentAimModule:ApplyPrediction(TargetPart, PredictionSettings)
    if not PredictionSettings.Enabled then
        return TargetPart.Position
    end
    local Velocity = TargetPart.Velocity
    local PredictedPosition = TargetPart.Position + Vector3.new(
        Velocity.X * PredictionSettings.X,
        Velocity.Y * PredictionSettings.Y,
        Velocity.Z * PredictionSettings.X
    )
    return PredictedPosition
end

function SilentAimModule:CheckHitChance(axis)
    local chance = (axis == "X") and Faith.SilentAim.HitChance.X or Faith.SilentAim.HitChance.Y
    return math.random(1, 100) <= chance
end

function SilentAimModule:GetCamlockTarget()
    local ClosestPlayer, ClosestDistance = nil, math.huge
    local ClosestTargetPart = nil
    local MousePos = Vector2.new(Mouse.X, Mouse.Y)
    
    for _, Player in pairs(Players:GetPlayers()) do
        if Player ~= LocalPlayer and Player.Character then
            local Character = Player.Character
            local Humanoid = Character:FindFirstChildOfClass("Humanoid")
            if Humanoid and (not Faith.Camlock.HealthCheck or Humanoid.Health > 0) then
                local TargetPart
                if Faith.Camlock.HitPartMode == "Closest" then
                    TargetPart = self:GetClosestPart(Character, MousePos)
                elseif Faith.Camlock.HitPartMode == "Random" then
                    TargetPart = self:GetRandomPart(Character)
                else
                    TargetPart = Character:FindFirstChild(Faith.Camlock.HitPart) or Character:FindFirstChild("HumanoidRootPart") or Character:FindFirstChild("UpperTorso") or Character:FindFirstChild("Torso")
                end
                
                if TargetPart and TargetPart.Parent then
                    local ScreenPos, Visible = Camera:WorldToViewportPoint(TargetPart.Position)
                    if Visible then
                        local Distance = (Vector2.new(ScreenPos.X, ScreenPos.Y) - MousePos).Magnitude
                        if Distance < ClosestDistance then
                            ClosestDistance = Distance
                            ClosestPlayer = Player
                            ClosestTargetPart = TargetPart
                        end
                    end
                end
            end
        end
    end
    
    Target = { Player = ClosestPlayer, TargetPart = ClosestTargetPart }
end

function SilentAimModule:CamlockMain()
    printAction("Camlock activated")
    if Faith.Camlock.KnifeCheck and self:IsHoldingKnife() then
        printAction("Camlock disabled due to knife check")
        if Tween then Tween:Cancel() end
        if Cycle then Cycle:Disconnect() end
        Target = { Player = nil, TargetPart = nil }
        return
    end
    
    self:GetCamlockTarget()
    if not Target.Player or not Target.TargetPart or not Target.TargetPart.Parent then
        printAction("No valid Camlock target found")
        if Cycle then Cycle:Disconnect() end
        if Tween then Tween:Cancel() end
        Target = { Player = nil, TargetPart = nil }
        return
    end
    
    printAction("Camlock targeting: " .. tostring(Target.Player.Name) .. " at " .. tostring(Target.TargetPart.Name))
    Cycle = RunService.RenderStepped:Connect(function()
        local success, err = pcall(function()
            if not Faith.Camlock.Enabled then
                printAction("Camlock stopped due to toggle off")
                if Tween then Tween:Cancel() end
                Cycle:Disconnect()
                Target = { Player = nil, TargetPart = nil }
                return
            end
            if Faith.Camlock.KnifeCheck and self:IsHoldingKnife() then
                printAction("Camlock stopped due to knife check")
                if Tween then Tween:Cancel() end
                Cycle:Disconnect()
                Target = { Player = nil, TargetPart = nil }
                return
            end
            
            local Character = Target.Player and Target.Player.Character
            if not Character or not Target.TargetPart or not Target.TargetPart.Parent then
                printAction("Camlock target lost")
                if Cycle then Cycle:Disconnect() end
                if Tween then Tween:Cancel() end
                Target = { Player = nil, TargetPart = nil }
                return
            end
            
            local Humanoid = Character:FindFirstChildOfClass("Humanoid")
            if not Faith.Camlock.HealthCheck or (Humanoid and Humanoid.Health > 0) then
                local targetPosition = Faith.Camlock.Prediction.Enabled and self:ApplyPrediction(Target.TargetPart, Faith.Camlock.Prediction) or Target.TargetPart.Position
                Info = TweenInfo.new(Faith.Camlock.Smoothing, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                local LookAt = CFrame.lookAt(Camera.CFrame.Position, targetPosition)
                Tween = TweenService:Create(Camera, Info, {CFrame = LookAt})
                Tween:Play()
            else
                printAction("Camlock stopped due to health check")
                if Cycle then Cycle:Disconnect() end
                if Tween then Tween:Cancel() end
                Target = { Player = nil, TargetPart = nil }
            end
        end)
        if not success then
            printAction("Camlock error: " .. tostring(err))
            if Cycle then Cycle:Disconnect() end
            if Tween then Tween:Cancel() end
            Target = { Player = nil, TargetPart = nil }
        end
    end)
end

function SilentAimModule:GetMagnitudeFromMouse(targetPart)
    local targetScreenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
    if onScreen then
        local mousePos = UserInputService:GetMouseLocation()
        return (Vector2.new(targetScreenPos.X, targetScreenPos.Y) - mousePos).Magnitude
    end
    return math.huge
end

local utility = {}
function utility.get_gun()
    for _, tool in next, game.Players.LocalPlayer.Character:GetChildren() do
        if tool:IsA("Tool") and tool:FindFirstChild("Ammo") then return tool end
    end
end

function utility.rapid(tool)
    tool:Activate()
    printAction("Rapid fire activated on: " .. tostring(tool.Name))
end

game:GetService("UserInputService").InputBegan:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton1 then
        local gun = utility.get_gun()
        if Faith.Misc.RapidFire.Enable and gun and not is_firing then
            is_firing = true
            printAction("Rapid fire started with: " .. tostring(gun.Name))
            while is_firing do
                utility.rapid(gun)
                task.wait(Faith.Misc.RapidFire.Delay)
            end
        end
    end
end)

game:GetService("UserInputService").InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        is_firing = false
        printAction("Rapid fire stopped")
    end
end)

game:GetService("UserInputService").InputBegan:Connect(function(Key, E)
    if E then return end
    if Faith.Camlock.Enabled and Key.KeyCode == Enum.KeyCode[Faith.Camlock.Bind:upper()] then
        IsToggled = not IsToggled
        if IsToggled then
            printAction("Camlock toggled on")
            SilentAimModule:CamlockMain()
        else
            printAction("Camlock toggled off")
            if Tween then Tween:Cancel() end
            if Cycle then Cycle:Disconnect() end
            Target = { Player = nil, TargetPart = nil }
        end
    end
end)

local success, grm = pcall(getrawmetatable, game)
if success and grm and grm.__index and setreadonly then
    local index = grm.__index
    setreadonly(grm, false)

    grm.__index = function(self, k)
        if not checkcaller() and self == LocalPlayer:GetMouse() and Faith.SilentAim.Enabled and not SilentAimModule:IsHoldingKnife() then
            if (k == "Hit" or k == "Target") and SilentAimModule:CheckHitChance("X") then
                local TargetPart = SilentAimModule:GetClosestPlayer()
                if TargetPart then
                    local Position = Faith.SilentAim.Prediction.Enabled and SilentAimModule:ApplyPrediction(TargetPart, Faith.SilentAim.Prediction) or TargetPart.Position
                    printAction("Silent Aim hit: " .. tostring(TargetPart.Parent.Name))
                    return CFrame.new(Position)
                end
            end
        end
        return index(self, k)
    end
else
    printAction("Metatable hooking not supported on this executor. Silent Aim disabled.")
    Faith.SilentAim.Enabled = false
end

RunService.RenderStepped:Connect(function()
    if Faith.SilentAim.Enabled then
        FOVCircle.Visible = Faith.SilentAim.FOV.Visible
        FOVCircle.Position = UserInputService:GetMouseLocation()
        FOVCircle.Radius = Faith.SilentAim.FOV.Radius
        FOVCircle.Color = Faith.SilentAim.FOV.OutlineColor
        FOVCircle.Transparency = Faith.SilentAim.FOV.Transparency
    else
        FOVCircle.Visible = false
    end
    printAction("FOV updated: Visible=" .. tostring(FOVCircle.Visible))
end)

return SilentAimModule
